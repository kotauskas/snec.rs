use std::convert::TryFrom;
use syn::{
    Ident,
    Expr,
    Path,
    Type,
    Visibility,
    Attribute,
    token,
    Token,
    parenthesized,
    bracketed,
    braced,
    punctuated::Punctuated,
    spanned::Spanned,
    parse::{Parse, ParseStream},
};
use proc_macro2::Span;

pub struct SnecAttribute {
    pub pound: Token![#],
    pub brackets: token::Bracket,
    pub path_span: Span,
    pub parentheses: Option<token::Paren>,
    pub body: Option<SnecAttributeBody>,
}
impl TryFrom<syn::Attribute> for SnecAttribute {
    type Error = syn::Error;
    #[inline]
    fn try_from(value: syn::Attribute) -> Result<Self, Self::Error> {
        if matches!(value.style, syn::AttrStyle::Inner(..)) {
            return Err(
                syn::Error::new(
                    value.span(),
                    "`snec` attributes cannot be inner (`#![...]` form)",
                )
            );
        }
        let pound = value.pound_token;
        let path_span = value.path.span();
        let brackets = value.bracket_token;
        let (parentheses, body) = if !value.tokens.is_empty() {
            let body_in_parentheses = syn::parse2::<SnecAttributeBodyInParentheses>(value.tokens)?;
            (
                Some(body_in_parentheses.parentheses),
                Some(body_in_parentheses.body),
            )
        } else {
            (None, None)
        };
        Ok(
            Self {pound, brackets, path_span, parentheses, body}
        )
    }
}
impl Parse for SnecAttribute {
    #[inline]
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let pound = input.parse()?;
        let inside_brackets;
        let brackets = bracketed!(inside_brackets in input);
        let path_span = {
            let ident = inside_brackets.parse::<Ident>()?;
            let span = ident.span();
            if ident == "snec" {
                span
            } else {
                return Err(
                    syn::Error::new(span, "expected `snec`")
                )
            }
        };
        let (parentheses, body) = if input.peek(token::Paren) {
            let body_in_parentheses = input.parse::<SnecAttributeBodyInParentheses>()?;
            (
                Some(body_in_parentheses.parentheses),
                Some(body_in_parentheses.body),
            )
        } else {
            (None, None)
        };
        Ok(
            Self {pound, brackets, path_span, parentheses, body}
        )
    }
}

struct SnecAttributeBodyInParentheses {
    parentheses: token::Paren,
    body: SnecAttributeBody,
}
impl Parse for SnecAttributeBodyInParentheses {
    #[inline]
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let inside_parentheses;
        let parentheses = parenthesized!(inside_parentheses in input);
        let body = inside_parentheses.parse()?;
        Ok(
            Self {parentheses, body}
        )
    }
}

pub struct SnecAttributeBody {
    pub commands: Punctuated<AttributeCommand, Token![,]>,
}
#[allow(clippy::clippy::eval_order_dependence)] // it's all clear and according to Syn docs
impl Parse for SnecAttributeBody {
    #[inline]
    fn parse(input: ParseStream) -> syn::Result<Self> {
        Ok(
            Self {
                commands: input.call(Punctuated::parse_terminated)?,
            }
        )
    }
}

pub enum AttributeCommand {
    /// Generate an marker and an `Entry` implementation in an additionally generated module, and a `Get` implementation fetching it.
    ///
    /// Usages:
    /// ```rust
    /// #[snec(entry)] // Infers name from struct field name and uses default receiver
    /// #[snec(entry(MyEntryType))] // Custom entry marker type name
    /// ```
    Entry {
        name: custom_token::Entry,
        parentheses: Option<token::Paren>,
        /// The name of the marker type as it appears in the module.
        value: Option<Ident>,
    },
    /// Generate a `Get` implementation for an existing marker type.
    ///
    /// Usage:
    /// ```rust
    /// #[snec(use_entry(MyEntryType))]
    /// ```
    UseEntry {
        name: custom_token::UseEntry,
        parentheses: token::Paren,
        /// The path to the marker type.
        value: Path,
    },
    /// Set the name for the module containing entries generated by the `Entry` command.
    ///
    /// Usage:
    /// ```rust
    /// #[snec(entry_module(my_own_module_name))]
    /// ```
    EntryModule {
        name: custom_token::EntryModule,
        parentheses: token::Paren,
        value: Ident,
    },
    /// Set the visibility for the module containing entries generated by the `Entry` command.
    ///
    /// Usage:
    /// ```rust
    /// #[snec(entry_module_visibility(pub))]
    /// ```
    EntryModuleVisibility {
        name: custom_token::EntryModuleVisibility,
        parentheses: token::Paren,
        value: Visibility,
    },
    /// Add attributes to the module containing entries generated by the `Entry` command. Must be outer, not inner.
    ///
    /// Usage:
    /// ```rust
    /// #[snec(entry_module_attributes(
    ///     /// This module has entry markers for my config struct!
    ///     #[my_fancy_attribute]
    /// ))]
    /// ```
    EntryModuleAttributes {
        name: custom_token::EntryModuleAttributes,
        parentheses: token::Paren,
        value: Vec<Attribute>,
    },
    /// Set the receiver, either for the whole struct or for a single field's generated `Entry` marker. Incompatible wih `UseEntry`.
    ///
    /// Usage:
    /// ```rust
    /// #[snec(receiver({MyReceiver::new()}: MyReceiver))]
    /// ```
    Receiver {
        name: custom_token::Receiver,
        parentheses: token::Paren,
        braces: token::Brace,
        /// Expression fetching a receiver to be pasted in the `get_handle` implementation.
        expression: Expr,
        colon: Token![:],
        /// The type of the expression
        ty: Type,
    },
}
/// Expands `#[snec]` to `#[snec(entry)]`.
impl Default for AttributeCommand {
    #[inline]
    fn default() -> Self {
        Self::Entry {
            name: custom_token::Entry(Span::call_site()),
            parentheses: None,
            value: None,
            
        }
    }
}
#[allow(clippy::clippy::eval_order_dependence)] // same here
impl Parse for AttributeCommand {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let ident = input.parse::<Ident>()?;
        let has_parentheses = input.lookahead1().peek(token::Paren);
        let parentheses = if has_parentheses {
            let inside_parentheses;
            let parentheses = parenthesized!(inside_parentheses in input);
            Some((parentheses, inside_parentheses))
        } else {None};
        let result = if ident == "entry" {
            let (
                parentheses,
                inside_parentheses,
            ) = if let Some((parentheses, inside_parentheses)) = parentheses {
                (Some(parentheses), Some(inside_parentheses))
            } else {
                (None, None)
            };
            Self::Entry {
                name: custom_token::Entry(ident.span()),
                parentheses,
                value: inside_parentheses.map(|input| input.parse()).transpose()?,
            }
        } else if ident == "receiver" {
            let (parentheses, inside_parentheses) = if let Some((
                parentheses,
                inside_parentheses,
            )) = parentheses {
                (parentheses, inside_parentheses)
            } else {
                return Err(
                    syn::Error::new(
                        ident.span(),
                        "`#[snec(receiver(...))]` attributes cannot be empty",
                    )
                )
            };
            let _inside_braces;
            // We're forking to make the braces count towards the expression to
            // make the attribute behave exactly as one would expect, that is,
            // giving the ability to group multiple statements and a final
            // expression as one expression.
            let braces = braced!(_inside_braces in inside_parentheses.fork());
            Self::Receiver {
                name: custom_token::Receiver(ident.span()),
                parentheses,
                braces,
                expression: inside_parentheses.parse()?,
                colon: inside_parentheses.parse()?,
                ty: inside_parentheses.parse()?,
            }
        } else if ident == "use_entry" {
            let (parentheses, inside_parentheses) = if let Some((
                parentheses,
                inside_parentheses,
            )) = parentheses {
                (parentheses, inside_parentheses)
            } else {
                return Err(
                    syn::Error::new(
                        ident.span(),
                        "`#[snec(use_entry(...))]` attributes cannot be empty",
                    )
                )
            };
            Self::UseEntry {
                name: custom_token::UseEntry(ident.span()),
                parentheses,
                value: inside_parentheses.parse()?,
            }
        } else if ident == "entry_module" {
            let (parentheses, inside_parentheses) = if let Some((
                parentheses,
                inside_parentheses,
            )) = parentheses {
                (parentheses, inside_parentheses)
            } else {
                return Err(
                    syn::Error::new(
                        ident.span(),
                        "`#[snec(entry_module(...))]` attributes cannot be empty",
                    )
                )
            };
            Self::EntryModule {
                name: custom_token::EntryModule(ident.span()),
                parentheses,
                value: inside_parentheses.parse()?,
            }
        } else if ident == "entry_module_visibility" {
            let (parentheses, inside_parentheses) = if let Some((
                parentheses,
                inside_parentheses,
            )) = parentheses {
                (parentheses, inside_parentheses)
            } else {
                return Err(
                    syn::Error::new(
                        ident.span(),
                        "`#[snec(entry_module_visibility(...))]` attributes cannot be empty",
                    )
                )
            };
            Self::EntryModuleVisibility {
                name: custom_token::EntryModuleVisibility(ident.span()),
                parentheses,
                value: inside_parentheses.parse()?,
            }
        } else if ident == "entry_module_attributes" {
            let (parentheses, inside_parentheses) = if let Some((
                parentheses,
                inside_parentheses,
            )) = parentheses {
                (parentheses, inside_parentheses)
            } else {
                return Err(
                    syn::Error::new(
                        ident.span(),
                        "`#[snec(entry_module_attributes(...))]` attributes cannot be empty",
                    )
                )
            };
            Self::EntryModuleAttributes {
                name: custom_token::EntryModuleAttributes(ident.span()),
                parentheses,
                value: inside_parentheses.call(Attribute::parse_outer)?,
            }
        } else {
            return Err(
                syn::Error::new(
                    ident.span(),
                    "expected `entry`, `receiver`, `use_entry` or `entry_module` command name"),
            )
        };
        Ok(result)
    }
}

pub enum AttributeCommandIter<I: Iterator<Item = AttributeCommand>> {
    Iterator(I),
    Single(Option<AttributeCommand>),
}
impl<I: Iterator<Item = AttributeCommand>> Iterator for AttributeCommandIter<I> {
    type Item = AttributeCommand;
    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        match self {
            Self::Iterator(i) => i.next(),
            Self::Single(c) => c.take(),
        }
    }
}
impl<I: Iterator<Item = AttributeCommand>> From<I> for AttributeCommandIter<I> {
    #[inline(always)]
    fn from(op: I) -> Self {
        Self::Iterator(op)
    }
}
impl<I: Iterator<Item = AttributeCommand>> From<AttributeCommand> for AttributeCommandIter<I> {
    fn from(op: AttributeCommand) -> Self {
        Self::Single(Some(op))
    }
}

pub mod custom_token {
    use syn::{
        Ident,
        parse::{Parse, ParseStream},
    };
    use proc_macro2::Span;
    
    macro_rules! custom_tokens {
        ($name:ident, $string:literal) => (
                        pub struct $name (pub Span);
            impl Parse for $name {
                #[inline]
                fn parse(input: ParseStream) -> syn::Result<Self> {
                    let ident = input.parse::<Ident>()?;
                    if ident == $string {
                        Ok(
                            Self(ident.span())
                        )
                    } else {
                        Err(
                            syn::Error::new(ident.span(), concat!("expected `", $string, "`"))
                        )
                    }
                }
            }
        );
        ($(($name:ident, $string:literal)),+ $(,)?) => (
            $(custom_tokens!($name, $string);)*
        );
    }

    custom_tokens! {
        // Root attribute name
        (Snec, "snec"),

        // Command names
        (Entry, "entry"),
        (Receiver, "receiver"),
        (UseEntry, "use_entry"),
        (EntryModule, "entry_module"),
        (EntryModuleVisibility, "entry_module_visibility"),
        (EntryModuleAttributes, "entry_module_attributes"),
    }
}